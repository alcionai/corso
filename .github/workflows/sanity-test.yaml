name: Sanity Testing
on: 
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      user:
        description: 'User to run sanity test on'

permissions:
  # required to retrieve AWS credentials
  id-token: write
  contents: write

# cancel currently running jobs if a new version of the branch is pushed
concurrency:
  group: sanity_testing-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  Sanity-Tests:
    environment: Testing
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY_SECRET }}
      AZURE_CLIENT_ID: ${{ secrets.CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
      AZURE_TENANT_ID: ${{ secrets.TENANT_ID }}
      CORSO_BUCKET: ${{ secrets.CI_TESTS_S3_BUCKET }}
      CORSO_LOG_DIR: testlog
      CORSO_LOG_FILE: ${{ env.CORSO_LOG_DIR }}/testlogging.log
      CORSO_M365_TEST_USER_ID: ${{ github.event.inputs.user != '' && github.event.inputs.user || vars.CORSO_M365_TEST_USER_ID }}
      CORSO_PASSPHRASE: ${{ secrets.INTEGRATION_TEST_CORSO_PASSPHRASE }}
      TEST_RESULT: test_results
      # The default working directory doesn't seem to apply to things without
      # the 'run' directive. https://stackoverflow.com/a/67845456
      WORKING_DIR: src

    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}
    steps:
      - uses: actions/checkout@v3

      - name: Setup Golang with cache
        uses: magnetikonline/action-golang-cache@v4
        with:
          go-version-file: src/go.mod

      - run: make build

      - run: go build -o sanityCheck ./cmd/sanity_test

      - run: mkdir ${TEST_RESULT}

      - run: mkdir ${CORSO_LOG_DIR}

      # run the tests
      - name: Version Test
        run: |  
          set -euo pipefail
          if [ $( ./corso --version | grep 'Corso version:' | wc -l) -ne 1 ]
          then
              echo "valid version not found"
              exit 1
          fi

      - name: Repo init test
        id: repo-init
        env:
          TEST_RESULT: "test_results"
        run: |
          set -euo pipefail 
          prefix=`date +"%Y-%m-%d-%T"`
          echo "Repo init test\n" >> ${CORSO_LOG_FILE}
          ./corso repo init s3 \
          --no-stats \
          --hide-progress \
          --prefix $prefix \
          --bucket  ${CORSO_BUCKET}  2>&1 | tee $TEST_RESULT/initrepo.txt 

          if ! grep -q 'Initialized a S3 repository within bucket' $TEST_RESULT/initrepo.txt 
          then
            echo "repo could not be initiated"
            exit 1
          fi
          
          echo result="$prefix" >> $GITHUB_OUTPUT 

      # run the tests
      - name: Repo connect test
        run: |
          set -euo pipefail
          echo "\nRepo connect test\n" >> ${CORSO_LOG_FILE}
          ./corso repo connect s3 \
          --no-stats \
          --hide-progress \
          --prefix ${{ steps.repo-init.outputs.result }} \
          --bucket  ${CORSO_BUCKET} 2>&1 | tee $TEST_RESULT/connect.txt 

          if ! grep -q 'Connected to S3 bucket' $TEST_RESULT/connect.txt 
          then
            echo "repo could not be connected"
            exit 1
          fi

      # generate new entries to roll into the next load test
      # only runs if the test was successful
      - name: New Data Creation
        working-directory: ./src/cmd/factory
        env:
          AZURE_CLIENT_ID: ${{ secrets.CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          AZURE_TENANT_ID: ${{ secrets.TENANT_ID }}
        run: |
          go run . exchange emails \
          --user ${{ env.CORSO_M365_TEST_USER_ID }} \
          --tenant ${{ env.AZURE_TENANT_ID }} \
          --destination Corso_Restore_st_${{ steps.repo-init.outputs.result }} \
          --count 4

      # run the tests
      - name: Backup exchange test
        id: exchange-test
        run: |
          echo "\nBackup Exchange test\n" >> ${CORSO_LOG_FILE}
          ./corso backup create exchange \
          --no-stats \
          --mailbox "${CORSO_M365_TEST_USER_ID}" \
          --hide-progress \
          --data 'email' \
          --json \
          2>&1 | tee $TEST_RESULT/backup_exchange.txt 

          resultjson=$(sed -e '1,/Completed Backups/d' $TEST_RESULT/backup_exchange.txt ) 

           if  [[ $( echo $resultjson | jq -r '.[0] | .stats.errorCount') -ne 0 ]]; then
            echo "backup was not successful"
            exit 1
          fi

          data=$( echo $resultjson | jq -r '.[0] | .id' )
          echo result=$data >> $GITHUB_OUTPUT

      # list all exchange backups
      - name: Backup exchange list test
        run: |
          set -euo pipefail
          echo "\nBackup Exchange list test\n" >> ${CORSO_LOG_FILE}
          ./corso backup list exchange \
          --no-stats \
          --hide-progress \
          2>&1 | tee $TEST_RESULT/backup_exchange_list.txt

          if ! grep -q  ${{ steps.exchange-test.outputs.result }} $TEST_RESULT/backup_exchange_list.txt 
          then
            echo "listing of backup was not successful"
            exit 1
          fi

      # list the previous exchange backups
      - name: Backup exchange list single backup test
        run: |
          set -euo pipefail
          echo "\nBackup Exchange list single backup test\n" >> ${CORSO_LOG_FILE}
          ./corso backup list exchange \
          --no-stats \
          --hide-progress \
          --backup "${{ steps.exchange-test.outputs.result }}" \
          2>&1 | tee $TEST_RESULT/backup_exchange_list_single.txt

          if ! grep -q  ${{ steps.exchange-test.outputs.result }} $TEST_RESULT/backup_exchange_list.txt 
          then
            echo "listing of backup was not successful"
            exit 1
          fi

      # test exchange restore
      - name: Backup exchange restore
        id: exchange-restore-test
        run: |
          set -euo pipefail
          echo "\nBackup Exchange restore test\n" >> ${CORSO_LOG_FILE}
          ./corso restore exchange \
          --no-stats \
          --email-folder Corso_Restore_st_${{ steps.repo-init.outputs.result }} \
          --hide-progress \
          --backup "${{ steps.exchange-test.outputs.result }}" \
          2>&1 | tee $TEST_RESULT/exchange-restore-test.txt
          echo result=$(grep -i -e 'Restoring to folder ' $TEST_RESULT/exchange-restore-test.txt | sed "s/Restoring to folder//" )  >> $GITHUB_OUTPUT
        
      - name: Restoration check
        env:
          SANITY_RESTORE_FOLDER: ${{ steps.exchange-restore-test.outputs.result }}
          SANITY_RESTORE_SERVICE: "exchange"
          TEST_DATA: Corso_Restore_st_${{ steps.repo-init.outputs.result }}
        run: |
          set -euo pipefail
          ./sanityCheck

      # test incremental backup exchange
      - name: Backup exchange incremental
        id: exchange-incremental-test
        run: |
          set -euo pipefail
          echo "\nBackup Exchange incremental test\n" >> ${CORSO_LOG_FILE}
          ./corso backup create exchange \
          --no-stats \
          --hide-progress \
          --mailbox "${CORSO_M365_TEST_USER_ID}" \
          --json \
          2>&1 | tee $TEST_RESULT/backup_exchange_incremental.txt 

          resultjson=$(sed -e '1,/Completed Backups/d' $TEST_RESULT/backup_exchange_incremental.txt ) 

          if  [[ $( echo $resultjson | jq -r '.[0] | .stats.errorCount') -ne 0 ]]; then
            echo "backup was not successful"
            exit 1
          fi

          echo result=$( echo $resultjson | jq -r '.[0] | .id' ) >> $GITHUB_OUTPUT

      # test exchange restore
      - name: Backup incremantal exchange restore
        id: exchange-incremantal-restore-test
        run: |
          set -euo pipefail
          echo "\nBackup Exchange incremental restore test\n" >> ${CORSO_LOG_FILE}
          ./corso restore exchange \
          --no-stats \
          --hide-progress \
          --backup "${{ steps.exchange-incremental-test.outputs.result }}" \
          --email-folder Corso_Restore_st_${{ steps.repo-init.outputs.result }} \
          2>&1 | tee $TEST_RESULT/exchange-incremantal-restore-test.txt
          echo result=$(grep -i -e 'Restoring to folder ' $TEST_RESULT/exchange-incremantal-restore-test.txt | sed "s/Restoring to folder//" )  >> $GITHUB_OUTPUT
        
      - name: Restoration check
        env:
          SANITY_RESTORE_FOLDER: ${{ steps.exchange-incremantal-restore-test.outputs.result }}
          SANITY_RESTORE_SERVICE: "exchange"
          TEST_DATA: Corso_Restore_st_${{ steps.repo-init.outputs.result }}
          BASE_BACKUP: ${{ steps.exchange-restore-test.outputs.result }}
        run: |
          set -euo pipefail
          ./sanityCheck

# Onedrive test

      # run the tests
      - name: Backup onedrive test
        id: onedrive-test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive test\n" >> ${CORSO_LOG_FILE}
          ./corso backup create onedrive \
          --no-stats \
          --hide-progress \
          --user "${CORSO_M365_TEST_USER_ID}" \
          --json \
          2>&1 | tee $TEST_RESULT/backup_onedrive.txt 

          resultjson=$(sed -e '1,/Completed Backups/d' $TEST_RESULT/backup_onedrive.txt ) 

          if  [[ $( echo $resultjson | jq -r '.[0] | .stats.errorCount') -ne 0 ]]; then
            echo "backup was not successful"
            exit 1
          fi

          data=$( echo $resultjson | jq -r '.[0] | .id' )
          echo result=$data >> $GITHUB_OUTPUT

      # list all onedrive backups
      - name: Backup onedrive list test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive list test\n" >> ${CORSO_LOG_FILE}
          ./corso backup list onedrive \
          --no-stats \
          --hide-progress \
          2>&1 | tee $TEST_RESULT/backup_onedrive_list.txt 

          if ! grep -q  ${{ steps.onedrive-test.outputs.result }} $TEST_RESULT/backup_onedrive_list.txt 
          then
            echo "listing of backup was not successful"
            exit 1
          fi

      # list the previous onedrive backup
      - name: Backup onedrive list one backup test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive list one backup test\n" >> ${CORSO_LOG_FILE}
          ./corso backup list onedrive \
          --no-stats \
          --hide-progress \
          --backup "${{ steps.onedrive-test.outputs.result }}" \
          2>&1 | tee $TEST_RESULT/backup_onedrive_list_single.txt

          if ! grep -q  ${{ steps.onedrive-test.outputs.result }} $TEST_RESULT/backup_onedrive_list.txt 
          then
            echo "listing of backup was not successful"
            exit 1
          fi

      # test onedrive restore
      - name: Backup onedrive restore
        id: onedrive-restore-test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive restore test\n" >> ${CORSO_LOG_FILE}
          ./corso restore onedrive \
          --no-stats \
          --restore-permissions \
          --hide-progress \
          --backup "${{ steps.onedrive-test.outputs.result }}" \
          2>&1 | tee $TEST_RESULT/onedrive-restore-test.txt 
          echo result=$(grep -i -e 'Restoring to folder ' $TEST_RESULT/onedrive-restore-test.txt | sed "s/Restoring to folder//")  >> $GITHUB_OUTPUT

      # Commenting for test cases to pass. And working on its fix
      # - name: Restoration oneDrive check
      #   env:
      #     SANITY_RESTORE_FOLDER: ${{ steps.onedrive-restore-test.outputs.result }}
      #     SANITY_RESTORE_SERVICE: "onedrive"
      #   run: |
      #     set -euo pipefail
      #     ./sanityCheck

      # test onedrive incremental
      - name: Backup onedrive incremental
        id: onedrive-incremental-test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive incremental test\n" >> ${CORSO_LOG_FILE}
          ./corso backup create onedrive \
          --no-stats \
          --hide-progress \
          --user "${CORSO_M365_TEST_USER_ID}" \
          --json \
          2>&1 | tee $TEST_RESULT/backup_onedrive_incremental.txt 
          
          resultjson=$(sed -e '1,/Completed Backups/d' $TEST_RESULT/backup_onedrive_incremental.txt ) 

          if  [[ $( echo $resultjson | jq -r '.[0] | .stats.errorCount') -ne 0 ]]; then
            echo "backup was not successful"
            exit 1
          fi

          data=$( echo $resultjson | jq -r '.[0] | .id' )
          echo result=$data >> $GITHUB_OUTPUT
          
      # test onedrive restore
      - name: Backup onedrive restore
        id: onedrive-incremental-restore-test
        run: |
          set -euo pipefail
          echo "\nBackup OneDrive incremental restore test\n" >> $CORSO_LOG_FILE
          ./corso restore onedrive \
          --no-stats \
          --restore-permissions \
          --hide-progress \
          --backup "${{ steps.onedrive-incremental-test.outputs.result }}" \
          2>&1 | tee $TEST_RESULT/onedrive-incremental-restore-test.txt 
          echo result=$(grep -i -e 'Restoring to folder ' $TEST_RESULT/onedrive-incremental-restore-test.txt | sed "s/Restoring to folder//")  >> $GITHUB_OUTPUT

      # Commenting for test cases to pass. And working on its fix
      # - name: Restoration oneDrive check
      #   env:
      #     SANITY_RESTORE_FOLDER: ${{ steps.onedrive-incremental-restore-test.outputs.result }}
      #     SANITY_RESTORE_SERVICE: "onedrive"
      #   run: |
      #     set -euo pipefail
      #     ./sanityCheck

      # Upload the original go test output as an artifact for later review.
      - name: Upload test log
        uses: actions/upload-artifact@v3
        with:
          name: test-logs
          path: ${{ env.WORKING_DIR }}/${{ env.CORSO_LOG_DIR }}/
          if-no-files-found: error
          retention-days: 14

      # run the tests
      - name: SHA info
        id: sha-info
        if: failure()
        run: |  
          echo ${GITHUB_REF#refs/heads/}-${GITHUB_SHA}
          echo SHA=${GITHUB_REF#refs/heads/}-${GITHUB_SHA} >> $GITHUB_OUTPUT
          echo RUN_URL=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}  >> $GITHUB_OUTPUT
          echo COMMIT_URL=${{ github.server_url }}/${{ github.repository }}/commit/${GITHUB_SHA} >> $GITHUB_OUTPUT

      
      - name: Send Github Action failure to Slack
        id: slack-notification
        if: failure()
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "text": "GitHub Action build result: ${{ job.status }} on SHA: ${{  steps.sha-info.outputs.SHA }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Failure in Sanity Test"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "<${{  steps.sha-info.outputs.RUN_URL }}|Check logs> for <${{  steps.sha-info.outputs.COMMIT_URL }}|${{  steps.sha-info.outputs.SHA }}>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
